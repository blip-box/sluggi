name: Adaptive Issue Triage

on:
  issues:
    types: [opened]
  pull_request:
    types: [opened, edited, reopened, synchronize]

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - name: Parse issue/PR for agent/human and auto-label
        uses: actions/github-script@v7
        with:
          script: |
            // Unified triage for issues and PRs
            const isPR = !!context.payload.pull_request;
            const body = isPR
              ? context.payload.pull_request.body || ''
              : context.payload.issue.body || '';
            let labels = ['triage'];
            let comment = '';
            if (body.match(/I am an agent\/bot/i)) {
              labels.push('agent');
              comment = isPR
                ? 'ðŸ¤– Agent PR received. Metadata will be parsed for triage.'
                : 'ðŸ¤– Agent issue received. Metadata will be parsed for triage.';
            } else if (body.match(/I am a human/i)) {
              labels.push('human');
              comment = isPR
                ? 'ðŸ™‹ Human PR received. Thanks for your contribution!'
                : 'ðŸ™‹ Human issue received. Thanks for your report!';
            }
            // Type detection from checkboxes
            if (body.match(/\[x\].*bug/i)) labels.push('bug');
            if (body.match(/\[x\].*feature/i)) labels.push('enhancement');
            if (body.match(/\[x\].*documentation/i)) labels.push('documentation');
            if (body.match(/\[x\].*question/i)) labels.push('question');
            if (body.match(/\[x\].*Agent\/automation change/i)) labels.push('agent-change');
            // Add labels
            await github.issues.addLabels({
              ...context.issue,
              labels
            });
            // Comment
            if (comment) {
              await github.issues.createComment({
                ...context.issue,
                body: comment
              });
            }
            // Parse JSON metadata if present
            const jsonMatch = body.match(/```json([\s\S]*?)```/i) || body.match(/```([\s\S]*?)```/i);
            if (jsonMatch) {
              try {
                const meta = JSON.parse(jsonMatch[1]);
                let metaSummary = Object.entries(meta).map(([k, v]) => `- **${k}**: ${v}`).join('\n');
                await github.issues.createComment({
                  ...context.issue,
                  body: `ðŸ”Ž Parsed metadata from body:\n${metaSummary}`
                });
              } catch (e) {
                // Ignore parse errors
              }
            }
            // Auto-close incomplete PRs (missing agent/human or summary)
            if (isPR) {
              const hasAgentOrHuman = body.match(/I am an agent\/bot/i) || body.match(/I am a human/i);
              const hasSummary = body.match(/\*\*Summary\*\*.*\n[\s\S]*?\S+/i);
              if (!hasAgentOrHuman || !hasSummary) {
                await github.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  state: 'closed'
                });
                await github.issues.createComment({
                  ...context.issue,
                  body: 'ðŸš« This PR was automatically closed because it is missing required agent/human identification or a summary. Please use the PR template.'
                });
                return;
              }
            }
            // Trigger additional workflow for agent-change PRs
            if (isPR && labels.includes('agent-change')) {
              await github.repos.createDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                event_type: 'agent-change-pr',
                client_payload: {
                  pr_number: context.payload.pull_request.number,
                  sender: context.actor
                }
              });
            }
